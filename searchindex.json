{"categories":[{"title":"ドキュメント","uri":"https://ugis70194.github.io/categories/%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88/"},{"title":"解説","uri":"https://ugis70194.github.io/categories/%E8%A7%A3%E8%AA%AC/"}],"posts":[{"content":"Markdown Preview Enhanced report format Visual Studio Code,Atomの拡張機能Markdown Preview Enhancedの拡張スクリプトです。\n図,表,式の番号を自動で振る、参照を自動で振るなどMarkdownをレポートに特化したフォーマットに自動で変換します。\nMarkdown Preview Enhancedの機能についてはこちらを参照してください。\nMarkdown Preview Enhanced 日本語ドキュメント\nMPE report format固有の記法 図のレンダリング alt属性は図のキャプションとなります。\n図には自動で番号が振られ、キャプションとともにセンタリングされます。\ninput ![キャプション](リンク)  output \n\u0026#x56F3;1. ugis70194  表のレンダリング 表の次に書いた\u0026lt;p\u0026gt;要素が表のキャプションとなります。 表には自動で番号が振られ、キャプションとともにセンタリングされます。\ninput | 順位 | パフォーマンス | 新Rating | 差分 | | ---- | -------------- | -------- | ---- | | 1075 | 1277 | 1239 | +4 | | 1682 | 1145 | 1235 | -9 | | 2332 | 1049 | 1244 | -20 | | 3566 | 912 | 1264 | -33 | | 1123 | 1478 | 1297 | +22 | | 960 | 1583 | 1275 | +40 | AtCoderにおける直近6回の成績  output \n  \u0026#x9806;\u0026#x4F4D; \u0026#x30D1;\u0026#x30D5;\u0026#x30A9;\u0026#x30FC;\u0026#x30DE;\u0026#x30F3;\u0026#x30B9; \u0026#x65B0;Rating \u0026#x5DEE;\u0026#x5206;     1075 1277 1239 +4   1682 1145 1235 -9   2332 1049 1244 -20   3566 912 1264 -33   1123 1478 1297 +22   960 1583 1275 +40    \u0026#x8868;1. AtCoder\u0026#x306B;\u0026#x304A;\u0026#x3051;\u0026#x308B;\u0026#x76F4;\u0026#x8FD1;6\u0026#x56DE;\u0026#x306E;\u0026#x6210;\u0026#x7E3E;\n数式のレンダリング $$で括った数式には自動で式番号が振られます。 数式は自動でセンタリングされます。\ninput $$ \\int x dx = \\frac{x^2}{2} + C$$ $$ \\int \\log x dx = x \\log x - x + C $$  output  参照の自動振り分け 図1,表1,式1, のように存在している番号の図,表,式には自動でアンカーが設定されます。\nクリックすることで対応する図,表,式の位置までジャンプします。\n表紙用のフロントマター 表紙を作るためのフロントマターです。\n適宜追加,変更することをおすすめします。\n^^^cover sub_date: 2021/4/21 subtitle: subtitle title: title exp_date: 2021/4/21 number: 70194 name: ugis collab: none ^^^  ","id":0,"section":"posts","summary":"Markdown Preview Enhanced report format Visual Studio Code,Atomの拡張機能Markdown Preview Enhancedの拡張スクリプトです。 図,表,式の番号を自動で振る、参照を自動で","tags":["ドキュメント"],"title":"MPE report format Documentation","uri":"https://ugis70194.github.io/2021/04/mpereport_format_documentation/","year":"2021"},{"content":"本選 1問目 目盛りのないストップウォッチ 問題 目盛りのないストップウォッチがある。このストップウォッチには、0を示す目印と針が一つずつついている。\n針は最初目印を指しており、ストップウォッチを起動すると時計回りに回転し始める。\n針が目印から$a$度回転した時の経過時間が$t (1 \\le t \\ le 1000)$秒であると分かっているとき、針の角度が$r$の時の経過時間を求めるプログラムを作成せよ。\nただし、$0 \\lt r \\lt 360$であるとする。\n解法 針の角度が$r$の時の経過時間を$T$とすれば、\n$a : t = r : T$が成り立つので、$T = \\cfrac{rt}{a}$となる。 したがって、$\\cfrac{rt}{a}$を出力すればよい。\n時間計算量のオーダーは$O(1)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ long double A, T, R; cin \u0026gt;\u0026gt; A \u0026gt;\u0026gt; T \u0026gt;\u0026gt; R; cout \u0026lt;\u0026lt; setprecision(8) \u0026lt;\u0026lt; R*T / A \u0026lt;\u0026lt; endl; }  本選 2問目 ガソリンスタンド 問題 このガソリンスタンドには$1$から$N$の番号が割り当てられた$N (1 \\le N \\le 10)$個のレーンがある。\nガソリンスタンドに入場した車は、並んでいる車が最も少ないレーンを選び列の末尾に並ぶ。 もし、そのようなレーンが複数ある場合は最も番号が小さいレーンの末尾に並ぶ。\nレーンの先頭の車から給油を行い、給油が終わると車はレーンから出ていく。\n一度レーンを選んだら車は他のレーンに移ることはなく、並び順が変わることもない。\nレーンの数、入場した車と給油が終了したレーンの情報が与えられたとき、給油が終了した車のナンバーを順番に出力するプログラムを作成せよ。 ただし、情報の数$M$は$2 \\le M \\le 10000$であるとする。\n解法 各レーンはキュー構造になっているので、$N$本のキューを用いてシミュレーションをすればよい。\n時間計算量のオーダーは$O(M)$となる。$M$の上限は$10000$なので十分高速である。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int N, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; vector\u0026lt;queue\u0026lt;int\u0026gt;\u0026gt; lanes(N); for(int i = 0; i \u0026lt; M; i++){ int b, n; cin \u0026gt;\u0026gt; b \u0026gt;\u0026gt; n; if(b == 0){ n--; cout \u0026lt;\u0026lt; lanes[n].front() \u0026lt;\u0026lt; endl; lanes[n].pop(); } else { int lane = 0; int len = 1e9; for(int l = 0; l \u0026lt; N; l++) { if(len \u0026gt; lanes[l].size()){ lane = l; len = lanes[l].size(); } } lanes[lane].push(n); } } }  本選 3問目 海苔 問題 二枚の長方形の海苔があります。\n二枚の海苔それぞれの左端の座標の幅と高さが与えられたとき、重なっていない部分の海苔の面積を出力するプログラムを作成せよ。\nただし、海苔の左端の座標$x,y$、幅$w$、高さ$h$は$(0 \\le x, y, w, h \\le 1000)$の範囲で与えられる。\n解法 全体の面積から重なっている部分の面積を引けばよい。\n簡単のために、より左側にある海苔を一枚目の海苔とする。 重なっている幅は$x+w - X$と$W$の小さい方か、その小さい方が負になる場合は$0$になる。 重なっている幅と高さはそれぞれ独立に求められるので、それぞれ独立に求めて重なっている面積を計算すれば良い。\n時間計算量のオーダーは$O(1)$になる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using i64 = long long; int main(){ i64 x, y, w, h; i64 X, Y, W, H; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y \u0026gt;\u0026gt; w \u0026gt;\u0026gt; h; cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; Y \u0026gt;\u0026gt; W \u0026gt;\u0026gt; H; if(x \u0026gt; X) { swap(x ,X), swap(y, Y), swap(w, W), swap(h, H); } i64 width = max(min(x+w - X, W), 0ll); if(y \u0026gt; Y) { swap(x ,X), swap(y, Y), swap(w, W), swap(h, H); } i64 height = max(min(y+h - Y, H), 0ll); cout \u0026lt;\u0026lt; (w*h + W*H) - 2*(width*height) \u0026lt;\u0026lt; endl; }  本選 4問目 へびの脱皮 問題 頭から尾にかけて一列にならんだマル(o)とバツ(x)からなる模様のへびが発見された。\nこのへびは脱皮のときに、2つのマルが並んだ部分の間すべてが伸びることで成長する。新たに加わった箇所にはマル、バツ、マルが並んだ模様がつく。\nへびの模様と脱皮の回数が与えられたとき、この回数だけ脱皮した後のへびの長さを求めるプログラムを作成せよ。\nただし、へびの長さ$L$は$1 \\le L \\ le 100$、脱皮の回数$N$は$1 \\le N \\le 50$であるとする。\n解法 マルがとなりあっている個数を$A$とすると$A$は脱皮の度に2倍になる。すると、 $A_{i+1} = 2A_{i}$という漸化式が成り立つ。この漸化式の一般項は$A_N = A_0(2^N - 1)$で与えられる。\nへびの長さの増加量はその3倍なので$N$回の脱皮で伸びる長さは$3A_N$となる。\nしたがって、最初のへびの長さを$L_0$とすれば$N$回脱皮した後のへびの長さ$L_N$は$L_N = L_0 + 3A_0(2^N-1)$となる。 最初にマルがとなりあっている個数を数えるのに$O(L)$時間かかるので、全体の時間計算量オーダーは$O(L)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using i64 = long long; i64 POW(i64 x, i64 n){ i64 res = 1; while(n){ if(n \u0026amp; 1) res *= x; x *= x; n \u0026gt;\u0026gt;= 1; } return res; } int main(){ i64 L, N; string snake; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; N \u0026gt;\u0026gt; snake; i64 A = 0; for(int i = 1; i \u0026lt; L; i++) { if(snake[i-1] == snake[i] \u0026amp;\u0026amp; snake[i] == 'o') A++; } cout \u0026lt;\u0026lt; L + 3ll*A*(POW(2, N) - 1ll) \u0026lt;\u0026lt; endl; }  ","id":1,"section":"posts","summary":"本選 1問目 目盛りのないストップウォッチ 問題 目盛りのないストップウォッチがある。このストップウォッチには、0を示す目印と針が一つずつついている","tags":["競プロ","PCK"],"title":"PCK2019 本選解説","uri":"https://ugis70194.github.io/2020/07/pck2019-ho/","year":"2020"},{"content":"予選 1問目 柴犬の数 問題 公園に4種類の柴犬がいます。 柴犬の数はそれぞれ、$R, B, W, G$で与えられる。 このとき、柴犬の総数を求めるプログラムを作成せよ。\nただし、$1 \\le R,B,W,G \\le 100$を満たす。\n解法 $R, B, W, G$すべてを足したものを出力すればよい。 時間計算量のオーダーは$O(1)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int R, B, W, G; cin \u0026gt;\u0026gt; R \u0026gt;\u0026gt; B \u0026gt;\u0026gt; W \u0026gt;\u0026gt; G; cout \u0026lt;\u0026lt; R + B + W + G \u0026lt;\u0026lt; endl; }  予選 2問目 アスキー文字 問題 コンピューター内部ではアルファベットの大文字\u0026rsquo;A\u0026rsquo;から\u0026rsquo;Z\u0026rsquo; に連続してそれぞれ数値の65から90が割り当てられており、同様に、小文字\u0026rsquo;a\u0026rsquo;から\u0026rsquo;z\u0026rsquo;にそれぞれ数値の97から122が割り当てられている。\n数値$N$が与えられたとき、アルファベットの大文字であれば1を、小文字であれば2を、それ以外であれば0を出力するプログラムを作成せよ。 ただし$N$は$1 \\le N \\le 127$を満たす。\n解法 if文を用いて、$N$が大文字の範囲内なら1を、小文字の範囲内なら2をそれ以外なら0を出力するようにする。\n時間計算量のオーダーは$O(1)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int N; cin \u0026gt;\u0026gt; N; if(65 \u0026lt;= N \u0026amp;\u0026amp; N \u0026lt;= 90) cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; else if(97 \u0026lt;= N \u0026amp;\u0026amp; N \u0026lt;= 122) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; }  予選 3問目 ２の累乗 問題 数値$N$が与えられる。\n$N$以下の数の中で最大の2の累乗を求めるプログラムを作成せよ。ただし、$N$は$1 \\le N \\le 10^6$を満たす。\n解法 数値のbit表現を利用する。bit表現においてbitが一つだけ立っているときは、10進数では2の累乗になる。\nしたがって、立っているbitを左にずらしたときに与えられた数より大きくならなければ、bitを左にずらし続ければよい。 時間計算量のオーダーは$O(\\log_2 N)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int N; cin \u0026gt;\u0026gt; N; int ans = 1; while(N \u0026gt;= (ans \u0026lt;\u0026lt; 1)) ans \u0026lt;\u0026lt;= 1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  予選 4問目 集会所 問題 東西に一直線に伸びる道路に沿った村がある。\n最も西の地点を0番目として、等間隔に東に向かって順に地区番号が与えられている。 ある時刻に一斉にすべての村人が自分の家から集会所に向かったとき、全員が集まるのに必要な時間が最小になるような場所に集会所を建てることにした。\n家の立っている地点の番号が与えられたとき、最適な場所に集会所と建てた場合に、すべての村人が集会所に集まるのに必要な時間の最小値を求めるプログラムを作成せよ。\nただし、家の数$N$は$1 \\le N \\le 1000$を、家が立っている地区番号$x_i$は$0 \\le x_i \\le 2000$を満たす。\n集会所はすで家が立っている地区に建ててもよい。 また、すべての村人は隣の地区まで1分で移動できるものとする。\n解法 集会所にたどり着くのに最も時間がかかるのは西の端か、東の端の家に住んでいる村人なので、そこだけ考えればよい。\nそして、集会所がこれら2つの地区のちょうど真ん中に建っているとき、村人全員が集会所に集まるまでにかかる時間が最小になる。\nしたがって、西の端の家から集会所までの距離と東の端から集会所までの距離のより大きい方が最小の時間になる。\n時間計算量のオーダーは$O(N)$となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int N; cin \u0026gt;\u0026gt; N; vector\u0026lt;int\u0026gt; X(N); for(int i = 0;i \u0026lt; N; i++) cin \u0026gt;\u0026gt; X[i]; int MIN = *min_element(begin(X), end(X)); int MAX = *max_element(begin(X), end(X)); int m = (MIN + MAX) / 2; cout \u0026lt;\u0026lt; max(abs(MIN - m), abs(MAX - m)) \u0026lt;\u0026lt; endl; }  予選 5問目 ねこのあな 問題 中が行き止まりになっている横穴がある。この横穴は猫がちょうど一匹入れるくらいの横幅で、奥行きは100匹の猫が入るのに十分である。 横穴に出入りした猫のリストが与えられるので、リストの先頭から順に見ていったとき、それより後ろを見なくても誤りと判定できる最初の位置を求めるプログラムを作成せよ。 ただし、猫は100匹いて、1から100までの番号が与えられているものとする。 $i$番目に横穴に入った猫の番号が$a_i$、出た猫の番号が#$-a_i$で与えられる。\nまた、リストの長さ$L$は$1 \\le L \\le 10000$の範囲で与えられる。\n解法 明らかに誤りなのは、リスト上で\n 既に横穴に入っている猫が横穴に入ったとき 一匹も横穴に入っていないのに猫が出てきたとき 一番最後に入った猫でない猫が出てきたとき 横穴に入っていない猫が出てきたとき の4つの状況が起こった場合である。\n横穴はスタック構造になっているのでスタックと配列を用いてシミュレーションをすればよい。 配列は今その番号の猫が横穴に入っているかどうかのフラグを管理するために用いる。\n上記4つをスタックと配列の操作に直せば以下のようになる。 今見ている値に横穴に入っているフラグが立っている スタックのサイズが0なのに今見ている値が負 スタックの一番上の値といま見ている値に-1をかけたものが異なる 今見ている値に-1をかけたものに横穴に入っているフラグが立っていない したがって、これらのパターンを検知するようにアルゴリズムを組めばよい。 リストを最後まで見る必要がある場合があるので、時間計算量は$O(L)$  コード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ int L; cin \u0026gt;\u0026gt; L; vector\u0026lt;int\u0026gt; C(L); for(int i = 0; i \u0026lt; L; i++) cin \u0026gt;\u0026gt; C[i]; vector\u0026lt;int\u0026gt; in(L+1,0); stack\u0026lt;int\u0026gt; s; int ans = 1e9; for(int i = 0; i\u0026lt; L; i++){ if(C[i] \u0026gt; 0){ if(in[C[i]]) ans = min(ans, i+1); else in[C[i]] = 1, s.push(C[i]); } if(C[i] \u0026lt; 0){ if(s.size() == 0) ans = min(ans, i+1); else if(in[-C[i]] \u0026amp;\u0026amp; s.top() != -C[i]) ans = min(ans, i+1); else if(!in[-C[i]]) ans = min(ans, i+1); else in[-C[i]] = 0, s.pop(); } } if(ans == 1e9) cout \u0026lt;\u0026lt; \u0026quot;OK\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; }  予選 6問目 床 問題 博士の家の床には正方形のタイルが敷きつめられている。はじめに部屋の適当なタイルをひとつ選び、以下の方法で色を塗っていく。\n タイルを塗る色を、赤、黄、青の順に変えていき、青の次はまた赤から始める。 すでに色を塗った領域の隣に正方形を追加し、そこに色を塗る。それらを合わせた領域が長方形になるようにする。正方形を追加する方向は、東、北、西、南の順に変えていき、南の次はまた東から始める。 最初に赤く塗ったタイルから東を$x$の正の方向、北を$y$の正の方向として、東西方向に$x$個,南北方向に$y$個移動したところにあるタイルの色を求めるプログラムを作成せよ。\nただし、$x, y$は$-10^6 \\le x, y \\le 10^6$の範囲で与えられる。  解法 正方形の一辺の長さは1, 1, 2, 3, 5 \u0026hellip;と大きくなる。\nこれはフィボナッチ数列であるので、$i$個目の正方形の一辺の長さは動的計画法を用いて高速に求められる。 最初に赤く塗ったタイルの左下端を原点(0,0)として、$i$個目の正方形の左下端の座標と右上端の座標をもっておけば、 座標(x,y)の位置のタイルが何個目の正方形に属しているかがわかる。\nしたがって、$i$個目の正方形の左下端の座標と右上端の座標、面積、色を最初に赤く塗ったタイルから順に求めていって、 座標(x, y)が正方形の中に入っているか逐次判定すればよい。\nフィボナッチ数列は2の累乗よりもすこし増加量が小さいので時間計算量はおおまかに$\\log (max(|x|, |y|))$程度となる。\nコード #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; using i64 = long long; struct coor{ pair\u0026lt;i64, i64\u0026gt; x, y; }; int main(){ i64 X,Y; cin \u0026gt;\u0026gt; X \u0026gt;\u0026gt; Y; vector\u0026lt;i64\u0026gt; fib(500); fib[0] = fib[1] = 1; for(int i = 2; i \u0026lt; 500; i++) { fib[i] = fib[i - 1] + fib[i - 2]; } coor now = {{0, 1}, {0, 1}}; i64 way = 0; i64 color = 0; int i = 1; while(i \u0026lt; 500){ //cout \u0026lt;\u0026lt; color \u0026lt;\u0026lt; \u0026quot; -----\u0026quot; \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; now.x.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; now.x.second \u0026lt;\u0026lt; endl; //cout \u0026lt;\u0026lt; now.y.first \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; now.y.second \u0026lt;\u0026lt; endl; if(now.x.first \u0026lt;= X \u0026amp;\u0026amp; X \u0026lt; now.x.second \u0026amp;\u0026amp; now.y.first \u0026lt;= Y \u0026amp;\u0026amp; Y \u0026lt; now.y.second){ cout \u0026lt;\u0026lt; color+1 \u0026lt;\u0026lt; endl; return 0; } coor next; if(way == 0) { next.x.first = now.x.second; next.x.second = next.x.first + fib[i]; next.y.first = now.y.first; next.y.second = next.y.first + fib[i]; } if(way == 1){ next.x.second = now.x.second; next.x.first = next.x.second - fib[i]; next.y.first = now.y.second; next.y.second = next.y.first + fib[i]; } if(way == 2){ next.x.second = now.x.first; next.x.first = next.x.second - fib[i]; next.y.second = now.y.second; next.y.first = now.y.second - fib[i]; } if(way == 3){ next.x.first = now.x.first; next.x.second = next.x.first + fib[i]; next.y.second = now.y.first; next.y.first = next.y.second - fib[i]; } now = next; i++, way++, color++; way %= 4; color %= 3; } cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; endl; }  ","id":2,"section":"posts","summary":"予選 1問目 柴犬の数 問題 公園に4種類の柴犬がいます。 柴犬の数はそれぞれ、$R, B, W, G$で与えられる。 このとき、柴犬の総数を求めるプログラムを作","tags":["競プロ","PCK"],"title":"PCK2019 予選解説","uri":"https://ugis70194.github.io/2020/07/pck2019-yo/","year":"2020"}],"tags":[{"title":"PCK","uri":"https://ugis70194.github.io/tags/pck/"},{"title":"ドキュメント","uri":"https://ugis70194.github.io/tags/%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88/"},{"title":"競プロ","uri":"https://ugis70194.github.io/tags/%E7%AB%B6%E3%83%97%E3%83%AD/"}]}